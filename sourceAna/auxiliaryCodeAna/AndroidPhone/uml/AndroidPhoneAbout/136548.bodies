class Phone
!!!164964.java!!!	getIccRecords() : IccRecords
        return mIccRecords.get();
!!!165092.java!!!	getPhoneName() : String
        return mName;
!!!165220.java!!!	setPhoneName(in name : String) : void
        mName = name;
!!!165348.java!!!	getNai() : String
         return null;
!!!165476.java!!!	getActionDetached() : String
        return mActionDetached;
!!!165604.java!!!	getActionAttached() : String
        return mActionAttached;
!!!165732.java!!!	setSystemProperty(in property : String, in value : String) : void
        if(getUnitTestMode()) {
            return;
        }
        SystemProperties.set(property, value);
!!!165860.java!!!	getSystemProperty(in property : String, in defValue : String) : String
        if(getUnitTestMode()) {
            return null;
        }
        return SystemProperties.get(property, defValue);
!!!165988.java!!!	Phone(in name : String, inout notifier : PhoneNotifier, inout context : Context, inout ci : CommandsInterface, inout unitTestMode : boolean)
        this(name, notifier, context, ci, unitTestMode, SubscriptionManager.DEFAULT_PHONE_INDEX,
                TelephonyComponentFactory.getInstance());
!!!166116.java!!!	Phone(in name : String, inout notifier : PhoneNotifier, inout context : Context, inout ci : CommandsInterface, inout unitTestMode : boolean, in phoneId : int, inout telephonyComponentFactory : TelephonyComponentFactory)
        mPhoneId = phoneId;
        mName = name;
        mNotifier = notifier;
        mContext = context;
        mLooper = Looper.myLooper();
        mCi = ci;
        mCarrierSignalAgent = new CarrierSignalAgent(this);
        mActionDetached = this.getClass().getPackage().getName() + ".action_detached";
        mActionAttached = this.getClass().getPackage().getName() + ".action_attached";

        if (Build.IS_DEBUGGABLE) {
            mTelephonyTester = new TelephonyTester(this);
        }

        setUnitTestMode(unitTestMode);

        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
        mDnsCheckDisabled = sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY, false);
        mCi.setOnCallRing(this, EVENT_CALL_RING, null);

        /* "Voice capable" means that this device supports circuit-switched
        * (i.e. voice) phone calls over the telephony network, and is allowed
        * to display the in-call UI while a cellular voice call is active.
        * This will be false on "data only" devices which can't make voice
        * calls and don't support any in-call UI.
        */
        mIsVoiceCapable = mContext.getResources().getBoolean(
                com.android.internal.R.bool.config_voice_capable);

        /**
         *  Some RIL's don't always send RIL_UNSOL_CALL_RING so it needs
         *  to be generated locally. Ideally all ring tones should be loops
         * and this wouldn't be necessary. But to minimize changes to upper
         * layers it is requested that it be generated by lower layers.
         *
         * By default old phones won't have the property set but do generate
         * the RIL_UNSOL_CALL_RING so the default if there is no property is
         * true.
         */
        mDoesRilSendMultipleCallRing = SystemProperties.getBoolean(
                TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
        Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);

        mCallRingDelay = SystemProperties.getInt(
                TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
        Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);

        if (getPhoneType() == PhoneConstants.PHONE_TYPE_IMS) {
            return;
        }

        // The locale from the "ro.carrier" system property or R.array.carrier_properties.
        // This will be overwritten by the Locale from the SIM language settings (EF-PL, EF-LI)
        // if applicable.
        final Locale carrierLocale = getLocaleFromCarrierProperties(mContext);
        if (carrierLocale != null && !TextUtils.isEmpty(carrierLocale.getCountry())) {
            final String country = carrierLocale.getCountry();
            try {
                Settings.Global.getInt(mContext.getContentResolver(),
                        Settings.Global.WIFI_COUNTRY_CODE);
            } catch (Settings.SettingNotFoundException e) {
                // note this is not persisting
                WifiManager wM = (WifiManager)
                        mContext.getSystemService(Context.WIFI_SERVICE);
                wM.setCountryCode(country, false);
            }
        }

        // Initialize device storage and outgoing SMS usage monitors for SMSDispatchers.
        mTelephonyComponentFactory = telephonyComponentFactory;
        mSmsStorageMonitor = mTelephonyComponentFactory.makeSmsStorageMonitor(this);
        mSmsUsageMonitor = mTelephonyComponentFactory.makeSmsUsageMonitor(context);
        mUiccController = UiccController.getInstance();
        mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null);
        if (getPhoneType() != PhoneConstants.PHONE_TYPE_SIP) {
            mCi.registerForSrvccStateChanged(this, EVENT_SRVCC_STATE_CHANGED, null);
        }
        mCi.setOnUnsolOemHookRaw(this, EVENT_UNSOL_OEM_HOOK_RAW, null);
        mCi.startLceService(DEFAULT_REPORT_INTERVAL_MS, LCE_PULL_MODE,
                obtainMessage(EVENT_CONFIG_LCE));
!!!166244.java!!!	startMonitoringImsService() : void
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_SIP) {
            return;
        }

        synchronized(Phone.lockForRadioTechnologyChange) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_UP);
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
            filter.addAction(ImsConfig.ACTION_IMS_CONFIG_CHANGED);
            mContext.registerReceiver(mImsIntentReceiver, filter);

            // Monitor IMS service - but first poll to see if already up (could miss
            // intent)
            ImsManager imsManager = ImsManager.getInstance(mContext, getPhoneId());
            if (imsManager != null && imsManager.isServiceAvailable()) {
                mImsServiceReady = true;
                updateImsPhone();
                ImsManager.updateImsServiceConfig(mContext, mPhoneId, false);
            }
        }
!!!166372.java!!!	handleMessage(inout msg : Message) : void
        AsyncResult ar;

        // messages to be handled whether or not the phone is being destroyed
        // should only include messages which are being re-directed and do not use
        // resources of the phone being destroyed
        switch (msg.what) {
            // handle the select network completion callbacks.
            case EVENT_SET_NETWORK_MANUAL_COMPLETE:
            case EVENT_SET_NETWORK_AUTOMATIC_COMPLETE:
                handleSetSelectNetwork((AsyncResult) msg.obj);
                return;
        }

        switch(msg.what) {
            case EVENT_CALL_RING:
                Rlog.d(LOG_TAG, "Event EVENT_CALL_RING Received state=" + getState());
                ar = (AsyncResult)msg.obj;
                if (ar.exception == null) {
                    PhoneConstants.State state = getState();
                    if ((!mDoesRilSendMultipleCallRing)
                            && ((state == PhoneConstants.State.RINGING) ||
                                    (state == PhoneConstants.State.IDLE))) {
                        mCallRingContinueToken += 1;
                        sendIncomingCallRingNotification(mCallRingContinueToken);
                    } else {
                        notifyIncomingRing();
                    }
                }
                break;

            case EVENT_CALL_RING_CONTINUE:
                Rlog.d(LOG_TAG, "Event EVENT_CALL_RING_CONTINUE Received state=" + getState());
                if (getState() == PhoneConstants.State.RINGING) {
                    sendIncomingCallRingNotification(msg.arg1);
                }
                break;

            case EVENT_ICC_CHANGED:
                onUpdateIccAvailability();
                break;

            case EVENT_INITIATE_SILENT_REDIAL:
                Rlog.d(LOG_TAG, "Event EVENT_INITIATE_SILENT_REDIAL Received");
                ar = (AsyncResult) msg.obj;
                if ((ar.exception == null) && (ar.result != null)) {
                    String dialString = (String) ar.result;
                    if (TextUtils.isEmpty(dialString)) return;
                    try {
                        dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, null);
                    } catch (CallStateException e) {
                        Rlog.e(LOG_TAG, "silent redial failed: " + e);
                    }
                }
                break;

            case EVENT_SRVCC_STATE_CHANGED:
                ar = (AsyncResult)msg.obj;
                if (ar.exception == null) {
                    handleSrvccStateChanged((int[]) ar.result);
                } else {
                    Rlog.e(LOG_TAG, "Srvcc exception: " + ar.exception);
                }
                break;

            case EVENT_UNSOL_OEM_HOOK_RAW:
                ar = (AsyncResult)msg.obj;
                if (ar.exception == null) {
                    byte[] data = (byte[])ar.result;
                    mNotifier.notifyOemHookRawEventForSubscriber(getSubId(), data);
                } else {
                    Rlog.e(LOG_TAG, "OEM hook raw exception: " + ar.exception);
                }
                break;

            case EVENT_CONFIG_LCE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    Rlog.d(LOG_TAG, "config LCE service failed: " + ar.exception);
                } else {
                    final ArrayList<Integer> statusInfo = (ArrayList<Integer>)ar.result;
                    mLceStatus = statusInfo.get(0);
                }
                break;

            case EVENT_CHECK_FOR_NETWORK_AUTOMATIC: {
                onCheckForNetworkSelectionModeAutomatic(msg);
                break;
            }
            default:
                throw new RuntimeException("unexpected event not handled");
        }
!!!166500.java!!!	getHandoverConnection() : ArrayList<Connection>
        return null;
!!!167012.java!!!	handleSrvccStateChanged(inout ret : int [[]]) : void
        Rlog.d(LOG_TAG, "handleSrvccStateChanged");

        ArrayList<Connection> conn = null;
        Phone imsPhone = mImsPhone;
        Call.SrvccState srvccState = Call.SrvccState.NONE;
        if (ret != null && ret.length != 0) {
            int state = ret[0];
            switch(state) {
                case VoLteServiceState.HANDOVER_STARTED:
                    srvccState = Call.SrvccState.STARTED;
                    if (imsPhone != null) {
                        conn = imsPhone.getHandoverConnection();
                        migrateFrom(imsPhone);
                    } else {
                        Rlog.d(LOG_TAG, "HANDOVER_STARTED: mImsPhone null");
                    }
                    break;
                case VoLteServiceState.HANDOVER_COMPLETED:
                    srvccState = Call.SrvccState.COMPLETED;
                    if (imsPhone != null) {
                        imsPhone.notifySrvccState(srvccState);
                    } else {
                        Rlog.d(LOG_TAG, "HANDOVER_COMPLETED: mImsPhone null");
                    }
                    break;
                case VoLteServiceState.HANDOVER_FAILED:
                case VoLteServiceState.HANDOVER_CANCELED:
                    srvccState = Call.SrvccState.FAILED;
                    break;

                default:
                    //ignore invalid state
                    return;
            }

            getCallTracker().notifySrvccState(srvccState, conn);

            VoLteServiceState lteState = new VoLteServiceState(state);
            notifyVoLteServiceStateChanged(lteState);
        }
!!!167140.java!!!	getContext() : Context
        return mContext;
!!!167396.java!!!	disableDnsCheck(inout b : boolean) : void
        mDnsCheckDisabled = b;
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        SharedPreferences.Editor editor = sp.edit();
        editor.putBoolean(DNS_SERVER_CHECK_DISABLED_KEY, b);
        editor.apply();
!!!167524.java!!!	isDnsCheckDisabled() : boolean
        return mDnsCheckDisabled;
!!!167652.java!!!	registerForPreciseCallStateChanged(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mPreciseCallStateRegistrants.addUnique(h, what, obj);
!!!167780.java!!!	unregisterForPreciseCallStateChanged(inout h : Handler) : void
        mPreciseCallStateRegistrants.remove(h);
!!!167908.java!!!	notifyPreciseCallStateChangedP() : void
        AsyncResult ar = new AsyncResult(null, this, null);
        mPreciseCallStateRegistrants.notifyRegistrants(ar);

        mNotifier.notifyPreciseCallState(this);
!!!168036.java!!!	registerForHandoverStateChanged(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);
        mHandoverRegistrants.addUnique(h, what, obj);
!!!168164.java!!!	unregisterForHandoverStateChanged(inout h : Handler) : void
        mHandoverRegistrants.remove(h);
!!!168292.java!!!	notifyHandoverStateChanged(inout cn : Connection) : void
       AsyncResult ar = new AsyncResult(null, cn, null);
       mHandoverRegistrants.notifyRegistrants(ar);
!!!168548.java!!!	migrateFrom(inout from : Phone) : void
        migrate(mHandoverRegistrants, from.mHandoverRegistrants);
        migrate(mPreciseCallStateRegistrants, from.mPreciseCallStateRegistrants);
        migrate(mNewRingingConnectionRegistrants, from.mNewRingingConnectionRegistrants);
        migrate(mIncomingRingRegistrants, from.mIncomingRingRegistrants);
        migrate(mDisconnectRegistrants, from.mDisconnectRegistrants);
        migrate(mServiceStateRegistrants, from.mServiceStateRegistrants);
        migrate(mMmiCompleteRegistrants, from.mMmiCompleteRegistrants);
        migrate(mMmiRegistrants, from.mMmiRegistrants);
        migrate(mUnknownConnectionRegistrants, from.mUnknownConnectionRegistrants);
        migrate(mSuppServiceFailedRegistrants, from.mSuppServiceFailedRegistrants);
        if (from.isInEmergencyCall()) {
            setIsInEmergencyCall();
        }
!!!168676.java!!!	migrate(inout to : RegistrantList, inout from : RegistrantList) : void
        from.removeCleared();
        for (int i = 0, n = from.size(); i < n; i++) {
            Registrant r = (Registrant) from.get(i);
            Message msg = r.messageForRegistrant();
            // Since CallManager has already registered with both CS and IMS phones,
            // the migrate should happen only for those registrants which are not
            // registered with CallManager.Hence the below check is needed to add
            // only those registrants to the registrant list which are not
            // coming from the CallManager.
            if (msg != null) {
                if (msg.obj == CallManager.getInstance().getRegistrantIdentifier()) {
                    continue;
                } else {
                    to.add((Registrant) from.get(i));
                }
            } else {
                Rlog.d(LOG_TAG, "msg is null");
            }
        }
!!!168804.java!!!	registerForUnknownConnection(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mUnknownConnectionRegistrants.addUnique(h, what, obj);
!!!168932.java!!!	unregisterForUnknownConnection(inout h : Handler) : void
        mUnknownConnectionRegistrants.remove(h);
!!!169060.java!!!	registerForNewRingingConnection(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mNewRingingConnectionRegistrants.addUnique(h, what, obj);
!!!169188.java!!!	unregisterForNewRingingConnection(inout h : Handler) : void
        mNewRingingConnectionRegistrants.remove(h);
!!!169316.java!!!	registerForVideoCapabilityChanged(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mVideoCapabilityChangedRegistrants.addUnique(h, what, obj);

        // Notify any registrants of the cached video capability as soon as they register.
        notifyForVideoCapabilityChanged(mIsVideoCapable);
!!!169444.java!!!	unregisterForVideoCapabilityChanged(inout h : Handler) : void
        mVideoCapabilityChangedRegistrants.remove(h);
!!!169572.java!!!	registerForInCallVoicePrivacyOn(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForInCallVoicePrivacyOn(h, what, obj);
!!!169700.java!!!	unregisterForInCallVoicePrivacyOn(inout h : Handler) : void
        mCi.unregisterForInCallVoicePrivacyOn(h);
!!!169828.java!!!	registerForInCallVoicePrivacyOff(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForInCallVoicePrivacyOff(h, what, obj);
!!!169956.java!!!	unregisterForInCallVoicePrivacyOff(inout h : Handler) : void
        mCi.unregisterForInCallVoicePrivacyOff(h);
!!!170084.java!!!	registerForIncomingRing(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mIncomingRingRegistrants.addUnique(h, what, obj);
!!!170212.java!!!	unregisterForIncomingRing(inout h : Handler) : void
        mIncomingRingRegistrants.remove(h);
!!!170340.java!!!	registerForDisconnect(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mDisconnectRegistrants.addUnique(h, what, obj);
!!!170468.java!!!	unregisterForDisconnect(inout h : Handler) : void
        mDisconnectRegistrants.remove(h);
!!!170596.java!!!	registerForSuppServiceFailed(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mSuppServiceFailedRegistrants.addUnique(h, what, obj);
!!!170724.java!!!	unregisterForSuppServiceFailed(inout h : Handler) : void
        mSuppServiceFailedRegistrants.remove(h);
!!!170852.java!!!	registerForMmiInitiate(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mMmiRegistrants.addUnique(h, what, obj);
!!!170980.java!!!	unregisterForMmiInitiate(inout h : Handler) : void
        mMmiRegistrants.remove(h);
!!!171108.java!!!	registerForMmiComplete(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mMmiCompleteRegistrants.addUnique(h, what, obj);
!!!171236.java!!!	unregisterForMmiComplete(inout h : Handler) : void
        checkCorrectThread(h);

        mMmiCompleteRegistrants.remove(h);
!!!171876.java!!!	setNetworkSelectionModeAutomatic(inout response : Message) : void
        Rlog.d(LOG_TAG, "setNetworkSelectionModeAutomatic, querying current mode");
        // we don't want to do this unecesarily - it acutally causes
        // the radio to repeate network selection and is costly
        // first check if we're already in automatic mode
        Message msg = obtainMessage(EVENT_CHECK_FOR_NETWORK_AUTOMATIC);
        msg.obj = response;
        mCi.getNetworkSelectionMode(msg);
!!!172004.java!!!	onCheckForNetworkSelectionModeAutomatic(inout fromRil : Message) : void
        AsyncResult ar = (AsyncResult)fromRil.obj;
        Message response = (Message)ar.userObj;
        boolean doAutomatic = true;
        if (ar.exception == null && ar.result != null) {
            try {
                int[] modes = (int[])ar.result;
                if (modes[0] == 0) {
                    // already confirmed to be in automatic mode - don't resend
                    doAutomatic = false;
                }
            } catch (Exception e) {
                // send the setting on error
            }
        }

        // wrap the response message in our own message along with
        // an empty string (to indicate automatic selection) for the
        // operator's id.
        NetworkSelectMessage nsm = new NetworkSelectMessage();
        nsm.message = response;
        nsm.operatorNumeric = "";
        nsm.operatorAlphaLong = "";
        nsm.operatorAlphaShort = "";

        if (doAutomatic) {
            Message msg = obtainMessage(EVENT_SET_NETWORK_AUTOMATIC_COMPLETE, nsm);
            mCi.setNetworkSelectionModeAutomatic(msg);
        } else {
            Rlog.d(LOG_TAG, "setNetworkSelectionModeAutomatic - already auto, ignoring");
            ar.userObj = nsm;
            handleSetSelectNetwork(ar);
        }

        updateSavedNetworkOperator(nsm);
!!!172132.java!!!	getNetworkSelectionMode(inout message : Message) : void
        mCi.getNetworkSelectionMode(message);
!!!172260.java!!!	selectNetworkManually(inout network : OperatorInfo, inout persistSelection : boolean, inout response : Message) : void
        // wrap the response message in our own message along with
        // the operator's id.
        NetworkSelectMessage nsm = new NetworkSelectMessage();
        nsm.message = response;
        nsm.operatorNumeric = network.getOperatorNumeric();
        nsm.operatorAlphaLong = network.getOperatorAlphaLong();
        nsm.operatorAlphaShort = network.getOperatorAlphaShort();

        Message msg = obtainMessage(EVENT_SET_NETWORK_MANUAL_COMPLETE, nsm);
        mCi.setNetworkSelectionModeManual(network.getOperatorNumeric(), msg);

        if (persistSelection) {
            updateSavedNetworkOperator(nsm);
        } else {
            clearSavedNetworkSelection();
        }
!!!172388.java!!!	registerForEmergencyCallToggle(inout h : Handler, in what : int, inout obj : Object) : void
        Registrant r = new Registrant(h, what, obj);
        mEmergencyCallToggledRegistrants.add(r);
!!!172516.java!!!	unregisterForEmergencyCallToggle(inout h : Handler) : void
        mEmergencyCallToggledRegistrants.remove(h);
!!!172644.java!!!	updateSavedNetworkOperator(inout nsm : Phone::NetworkSelectMessage) : void
        int subId = getSubId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            // open the shared preferences editor, and write the value.
            // nsm.operatorNumeric is "" if we're in automatic.selection.
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            SharedPreferences.Editor editor = sp.edit();
            editor.putString(NETWORK_SELECTION_KEY + subId, nsm.operatorNumeric);
            editor.putString(NETWORK_SELECTION_NAME_KEY + subId, nsm.operatorAlphaLong);
            editor.putString(NETWORK_SELECTION_SHORT_KEY + subId, nsm.operatorAlphaShort);

            // commit and log the result.
            if (!editor.commit()) {
                Rlog.e(LOG_TAG, "failed to commit network selection preference");
            }
        } else {
            Rlog.e(LOG_TAG, "Cannot update network selection preference due to invalid subId " +
                    subId);
        }
!!!172772.java!!!	handleSetSelectNetwork(inout ar : AsyncResult) : void
        // look for our wrapper within the asyncresult, skip the rest if it
        // is null.
        if (!(ar.userObj instanceof NetworkSelectMessage)) {
            Rlog.e(LOG_TAG, "unexpected result from user object.");
            return;
        }

        NetworkSelectMessage nsm = (NetworkSelectMessage) ar.userObj;

        // found the object, now we send off the message we had originally
        // attached to the request.
        if (nsm.message != null) {
            AsyncResult.forMessage(nsm.message, ar.result, ar.exception);
            nsm.message.sendToTarget();
        }
!!!172900.java!!!	getSavedNetworkSelection() : OperatorInfo
        // open the shared preferences and search with our key.
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        String numeric = sp.getString(NETWORK_SELECTION_KEY + getSubId(), "");
        String name = sp.getString(NETWORK_SELECTION_NAME_KEY + getSubId(), "");
        String shrt = sp.getString(NETWORK_SELECTION_SHORT_KEY + getSubId(), "");
        return new OperatorInfo(name, shrt, numeric);
!!!173028.java!!!	clearSavedNetworkSelection() : void
        // open the shared preferences and search with our key.
        PreferenceManager.getDefaultSharedPreferences(getContext()).edit().
                remove(NETWORK_SELECTION_KEY + getSubId()).
                remove(NETWORK_SELECTION_NAME_KEY + getSubId()).
                remove(NETWORK_SELECTION_SHORT_KEY + getSubId()).commit();
!!!173156.java!!!	restoreSavedNetworkSelection(inout response : Message) : void
        // retrieve the operator
        OperatorInfo networkSelection = getSavedNetworkSelection();

        // set to auto if the id is empty, otherwise select the network.
        if (networkSelection == null || TextUtils.isEmpty(networkSelection.getOperatorNumeric())) {
            setNetworkSelectionModeAutomatic(response);
        } else {
            selectNetworkManually(networkSelection, true, response);
        }
!!!173284.java!!!	saveClirSetting(in commandInterfaceCLIRMode : int) : void
        // Open the shared preferences editor, and write the value.
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        SharedPreferences.Editor editor = sp.edit();
        editor.putInt(CLIR_KEY + getPhoneId(), commandInterfaceCLIRMode);

        // Commit and log the result.
        if (!editor.commit()) {
            Rlog.e(LOG_TAG, "Failed to commit CLIR preference");
        }
!!!173412.java!!!	setUnitTestMode(inout f : boolean) : void
        mUnitTestMode = f;
!!!173540.java!!!	getUnitTestMode() : boolean
        return mUnitTestMode;
!!!173668.java!!!	notifyDisconnectP(inout cn : Connection) : void
        AsyncResult ar = new AsyncResult(null, cn, null);
        mDisconnectRegistrants.notifyRegistrants(ar);
!!!173796.java!!!	registerForServiceStateChanged(inout h : Handler, in what : int, inout obj : Object) : void
        checkCorrectThread(h);

        mServiceStateRegistrants.add(h, what, obj);
!!!173924.java!!!	unregisterForServiceStateChanged(inout h : Handler) : void
        mServiceStateRegistrants.remove(h);
!!!174052.java!!!	registerForRingbackTone(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForRingbackTone(h, what, obj);
!!!174180.java!!!	unregisterForRingbackTone(inout h : Handler) : void
        mCi.unregisterForRingbackTone(h);
!!!174564.java!!!	registerForResendIncallMute(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForResendIncallMute(h, what, obj);
!!!174692.java!!!	unregisterForResendIncallMute(inout h : Handler) : void
        mCi.unregisterForResendIncallMute(h);
!!!174820.java!!!	setEchoSuppressionEnabled() : void
        // no need for regular phone
!!!174948.java!!!	notifyServiceStateChangedP(inout ss : ServiceState) : void
        AsyncResult ar = new AsyncResult(null, ss, null);
        mServiceStateRegistrants.notifyRegistrants(ar);

        mNotifier.notifyServiceState(this);
!!!175076.java!!!	getSimulatedRadioControl() : SimulatedRadioControl
        return mSimulatedRadioControl;
!!!175204.java!!!	checkCorrectThread(inout h : Handler) : void
        if (h.getLooper() != mLooper) {
            throw new RuntimeException(
                    "com.android.internal.telephony.Phone must be used from within one thread");
        }
!!!175332.java!!!	getLocaleFromCarrierProperties(inout ctx : Context) : Locale
        String carrier = SystemProperties.get("ro.carrier");

        if (null == carrier || 0 == carrier.length() || "unknown".equals(carrier)) {
            return null;
        }

        CharSequence[] carrierLocales = ctx.getResources().getTextArray(R.array.carrier_properties);

        for (int i = 0; i < carrierLocales.length; i+=3) {
            String c = carrierLocales[i].toString();
            if (carrier.equals(c)) {
                return Locale.forLanguageTag(carrierLocales[i + 1].toString().replace('_', '-'));
            }
        }

        return null;
!!!175588.java!!!	getIccFileHandler() : IccFileHandler
        UiccCardApplication uiccApplication = mUiccApplication.get();
        IccFileHandler fh;

        if (uiccApplication == null) {
            Rlog.d(LOG_TAG, "getIccFileHandler: uiccApplication == null, return null");
            fh = null;
        } else {
            fh = uiccApplication.getIccFileHandler();
        }

        Rlog.d(LOG_TAG, "getIccFileHandler: fh=" + fh);
        return fh;
!!!175716.java!!!	getHandler() : Handler
        return this;
!!!175972.java!!!	getServiceStateTracker() : ServiceStateTracker
        return null;
!!!176100.java!!!	getCallTracker() : CallTracker
        return null;
!!!176228.java!!!	updateVoiceMail() : void
        Rlog.e(LOG_TAG, "updateVoiceMail() should be overridden");
!!!176356.java!!!	getCurrentUiccAppType() : AppType
        UiccCardApplication currentApp = mUiccApplication.get();
        if (currentApp != null) {
            return currentApp.getType();
        }
        return AppType.APPTYPE_UNKNOWN;
!!!176484.java!!!	getIccCard() : IccCard
        return null;
        //throw new Exception("getIccCard Shouldn't be called from Phone");
!!!176612.java!!!	getIccSerialNumber() : String
        IccRecords r = mIccRecords.get();
        return (r != null) ? r.getIccId() : null;
!!!176740.java!!!	getFullIccSerialNumber() : String
        IccRecords r = mIccRecords.get();
        return (r != null) ? r.getFullIccId() : null;
!!!176868.java!!!	getIccRecordsLoaded() : boolean
        IccRecords r = mIccRecords.get();
        return (r != null) ? r.getRecordsLoaded() : false;
!!!176996.java!!!	getAllCellInfo() : List<CellInfo>
        List<CellInfo> cellInfoList = getServiceStateTracker().getAllCellInfo();
        return privatizeCellInfoList(cellInfoList);
!!!177124.java!!!	privatizeCellInfoList(inout cellInfoList : List<CellInfo>) : List<CellInfo>
        if (cellInfoList == null) return null;
        int mode = Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
        if (mode == Settings.Secure.LOCATION_MODE_OFF) {
            ArrayList<CellInfo> privateCellInfoList = new ArrayList<CellInfo>(cellInfoList.size());
            // clear lat/lon values for location privacy
            for (CellInfo c : cellInfoList) {
                if (c instanceof CellInfoCdma) {
                    CellInfoCdma cellInfoCdma = (CellInfoCdma) c;
                    CellIdentityCdma cellIdentity = cellInfoCdma.getCellIdentity();
                    CellIdentityCdma maskedCellIdentity = new CellIdentityCdma(
                            cellIdentity.getNetworkId(),
                            cellIdentity.getSystemId(),
                            cellIdentity.getBasestationId(),
                            Integer.MAX_VALUE, Integer.MAX_VALUE);
                    CellInfoCdma privateCellInfoCdma = new CellInfoCdma(cellInfoCdma);
                    privateCellInfoCdma.setCellIdentity(maskedCellIdentity);
                    privateCellInfoList.add(privateCellInfoCdma);
                } else {
                    privateCellInfoList.add(c);
                }
            }
            cellInfoList = privateCellInfoList;
        }
        return cellInfoList;
!!!177252.java!!!	setCellInfoListRate(in rateInMillis : int) : void
        mCi.setCellInfoListRate(rateInMillis, null);
!!!177380.java!!!	getMessageWaitingIndicator() : boolean
        return mVmCount != 0;
!!!177508.java!!!	getCallForwardingIndicatorFromSharedPref() : int
        int status = IccRecords.CALL_FORWARDING_STATUS_DISABLED;
        int subId = getSubId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            status = sp.getInt(CF_STATUS + subId, IccRecords.CALL_FORWARDING_STATUS_UNKNOWN);
            Rlog.d(LOG_TAG, "getCallForwardingIndicatorFromSharedPref: for subId " + subId + "= " +
                    status);
            // Check for old preference if status is UNKNOWN for current subId. This part of the
            // code is needed only when upgrading from M to N.
            if (status == IccRecords.CALL_FORWARDING_STATUS_UNKNOWN) {
                String subscriberId = sp.getString(CF_ID, null);
                if (subscriberId != null) {
                    String currentSubscriberId = getSubscriberId();

                    if (subscriberId.equals(currentSubscriberId)) {
                        // get call forwarding status from preferences
                        status = sp.getInt(CF_STATUS, IccRecords.CALL_FORWARDING_STATUS_DISABLED);
                        setCallForwardingIndicatorInSharedPref(
                                status == IccRecords.CALL_FORWARDING_STATUS_ENABLED ? true : false);
                        Rlog.d(LOG_TAG, "getCallForwardingIndicatorFromSharedPref: " + status);
                    } else {
                        Rlog.d(LOG_TAG, "getCallForwardingIndicatorFromSharedPref: returning " +
                                "DISABLED as status for matching subscriberId not found");
                    }

                    // get rid of old preferences.
                    SharedPreferences.Editor editor = sp.edit();
                    editor.remove(CF_ID);
                    editor.remove(CF_STATUS);
                    editor.apply();
                }
            }
        } else {
            Rlog.e(LOG_TAG, "getCallForwardingIndicatorFromSharedPref: invalid subId " + subId);
        }
        return status;
!!!177636.java!!!	setCallForwardingIndicatorInSharedPref(inout enable : boolean) : void
        int status = enable ? IccRecords.CALL_FORWARDING_STATUS_ENABLED :
                IccRecords.CALL_FORWARDING_STATUS_DISABLED;
        int subId = getSubId();
        Rlog.d(LOG_TAG, "setCallForwardingIndicatorInSharedPref: Storing status = " + status +
                " in pref " + CF_STATUS + subId);

        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
        SharedPreferences.Editor editor = sp.edit();
        editor.putInt(CF_STATUS + subId, status);
        editor.apply();
!!!177764.java!!!	setVoiceCallForwardingFlag(in line : int, inout enable : boolean, in number : String) : void
        setCallForwardingIndicatorInSharedPref(enable);
        IccRecords r = mIccRecords.get();
        if (r != null) {
            r.setVoiceCallForwardingFlag(line, enable, number);
        }
!!!177892.java!!!	setVoiceCallForwardingFlag(inout r : IccRecords, in line : int, inout enable : boolean, in number : String) : void
        setCallForwardingIndicatorInSharedPref(enable);
        r.setVoiceCallForwardingFlag(line, enable, number);
!!!178020.java!!!	getCallForwardingIndicator() : boolean
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            Rlog.e(LOG_TAG, "getCallForwardingIndicator: not possible in CDMA");
            return false;
        }
        IccRecords r = mIccRecords.get();
        int callForwardingIndicator = IccRecords.CALL_FORWARDING_STATUS_UNKNOWN;
        if (r != null) {
            callForwardingIndicator = r.getVoiceCallForwardingFlag();
        }
        if (callForwardingIndicator == IccRecords.CALL_FORWARDING_STATUS_UNKNOWN) {
            callForwardingIndicator = getCallForwardingIndicatorFromSharedPref();
        }
        return (callForwardingIndicator == IccRecords.CALL_FORWARDING_STATUS_ENABLED);
!!!178148.java!!!	getCarrierSignalAgent() : CarrierSignalAgent
        return mCarrierSignalAgent;
!!!178276.java!!!	queryCdmaRoamingPreference(inout response : Message) : void
        mCi.queryCdmaRoamingPreference(response);
!!!178404.java!!!	getSignalStrength() : SignalStrength
        ServiceStateTracker sst = getServiceStateTracker();
        if (sst == null) {
            return new SignalStrength();
        } else {
            return sst.getSignalStrength();
        }
!!!178532.java!!!	setCdmaRoamingPreference(in cdmaRoamingType : int, inout response : Message) : void
        mCi.setCdmaRoamingPreference(cdmaRoamingType, response);
!!!178660.java!!!	setCdmaSubscription(in cdmaSubscriptionType : int, inout response : Message) : void
        mCi.setCdmaSubscriptionSource(cdmaSubscriptionType, response);
!!!178788.java!!!	setPreferredNetworkType(in networkType : int, inout response : Message) : void
        // Only set preferred network types to that which the modem supports
        int modemRaf = getRadioAccessFamily();
        int rafFromType = RadioAccessFamily.getRafFromNetworkType(networkType);

        if (modemRaf == RadioAccessFamily.RAF_UNKNOWN
                || rafFromType == RadioAccessFamily.RAF_UNKNOWN) {
            Rlog.d(LOG_TAG, "setPreferredNetworkType: Abort, unknown RAF: "
                    + modemRaf + " " + rafFromType);
            if (response != null) {
                CommandException ex;

                ex = new CommandException(CommandException.Error.GENERIC_FAILURE);
                AsyncResult.forMessage(response, null, ex);
                response.sendToTarget();
            }
            return;
        }

        int filteredRaf = (rafFromType & modemRaf);
        int filteredType = RadioAccessFamily.getNetworkTypeFromRaf(filteredRaf);

        Rlog.d(LOG_TAG, "setPreferredNetworkType: networkType = " + networkType
                + " modemRaf = " + modemRaf
                + " rafFromType = " + rafFromType
                + " filteredType = " + filteredType);

        mCi.setPreferredNetworkType(filteredType, response);
!!!178916.java!!!	getPreferredNetworkType(inout response : Message) : void
        mCi.getPreferredNetworkType(response);
!!!179044.java!!!	getSmscAddress(inout result : Message) : void
        mCi.getSmscAddress(result);
!!!179172.java!!!	setSmscAddress(in address : String, inout result : Message) : void
        mCi.setSmscAddress(address, result);
!!!179300.java!!!	setTTYMode(in ttyMode : int, inout onComplete : Message) : void
        mCi.setTTYMode(ttyMode, onComplete);
!!!179428.java!!!	setUiTTYMode(in uiTtyMode : int, inout onComplete : Message) : void
        Rlog.d(LOG_TAG, "unexpected setUiTTYMode method call");
!!!179556.java!!!	queryTTYMode(inout onComplete : Message) : void
        mCi.queryTTYMode(onComplete);
!!!179940.java!!!	setBandMode(in bandMode : int, inout response : Message) : void
        mCi.setBandMode(bandMode, response);
!!!180068.java!!!	queryAvailableBandMode(inout response : Message) : void
        mCi.queryAvailableBandMode(response);
!!!180196.java!!!	invokeOemRilRequestRaw(inout data : byte [[]], inout response : Message) : void
        mCi.invokeOemRilRequestRaw(data, response);
!!!180324.java!!!	invokeOemRilRequestStrings(inout strings : String [[]], inout response : Message) : void
        mCi.invokeOemRilRequestStrings(strings, response);
!!!180452.java!!!	nvReadItem(in itemID : int, inout response : Message) : void
        mCi.nvReadItem(itemID, response);
!!!180580.java!!!	nvWriteItem(in itemID : int, in itemValue : String, inout response : Message) : void
        mCi.nvWriteItem(itemID, itemValue, response);
!!!180708.java!!!	nvWriteCdmaPrl(inout preferredRoamingList : byte [[]], inout response : Message) : void
        mCi.nvWriteCdmaPrl(preferredRoamingList, response);
!!!180836.java!!!	nvResetConfig(in resetType : int, inout response : Message) : void
        mCi.nvResetConfig(resetType, response);
!!!180964.java!!!	notifyDataActivity() : void
        mNotifier.notifyDataActivity(this);
!!!181092.java!!!	notifyMessageWaitingIndicator() : void
        // Do not notify voice mail waiting if device doesn't support voice
        if (!mIsVoiceCapable)
            return;

        // This function is added to send the notification to DefaultPhoneNotifier.
        mNotifier.notifyMessageWaitingChanged(this);
!!!181220.java!!!	notifyDataConnection(in reason : String, in apnType : String, inout state : PhoneConstants.DataState) : void
        mNotifier.notifyDataConnection(this, reason, apnType, state);
!!!181348.java!!!	notifyDataConnection(in reason : String, in apnType : String) : void
        mNotifier.notifyDataConnection(this, reason, apnType, getDataConnectionState(apnType));
!!!181476.java!!!	notifyDataConnection(in reason : String) : void
        String types[] = getActiveApnTypes();
        for (String apnType : types) {
            mNotifier.notifyDataConnection(this, reason, apnType, getDataConnectionState(apnType));
        }
!!!181604.java!!!	notifyOtaspChanged(in otaspMode : int) : void
        mNotifier.notifyOtaspChanged(this, otaspMode);
!!!181732.java!!!	notifySignalStrength() : void
        mNotifier.notifySignalStrength(this);
!!!181860.java!!!	notifyCellInfo(inout cellInfo : List<CellInfo>) : void
        mNotifier.notifyCellInfo(this, privatizeCellInfoList(cellInfo));
!!!181988.java!!!	notifyVoLteServiceStateChanged(inout lteState : VoLteServiceState) : void
        mNotifier.notifyVoLteServiceStateChanged(this, lteState);
!!!182116.java!!!	isInEmergencyCall() : boolean
        return false;
!!!182244.java!!!	isInEcm() : boolean
        return false;
!!!182372.java!!!	getVideoState(inout call : Call) : int
        int videoState = VideoProfile.STATE_AUDIO_ONLY;
        Connection conn = call.getEarliestConnection();
        if (conn != null) {
            videoState = conn.getVideoState();
        }
        return videoState;
!!!182500.java!!!	isVideoCallOrConference(inout call : Call) : boolean
        if (call.isMultiparty()) {
            return true;
        }

        boolean isDowngradedVideoCall = false;
        if (call instanceof ImsPhoneCall) {
            ImsPhoneCall imsPhoneCall = (ImsPhoneCall) call;
            ImsCall imsCall = imsPhoneCall.getImsCall();
            return imsCall != null && (imsCall.isVideoCall() ||
                    imsCall.wasVideoCall());
        }
        return isDowngradedVideoCall;
!!!182628.java!!!	isImsVideoCallOrConferencePresent() : boolean
        boolean isPresent = false;
        if (mImsPhone != null) {
            isPresent = isVideoCallOrConference(mImsPhone.getForegroundCall()) ||
                    isVideoCallOrConference(mImsPhone.getBackgroundCall()) ||
                    isVideoCallOrConference(mImsPhone.getRingingCall());
        }
        Rlog.d(LOG_TAG, "isImsVideoCallOrConferencePresent: " + isPresent);
        return isPresent;
!!!182884.java!!!	getVoiceMessageCount() : int
        return mVmCount;
!!!183012.java!!!	setVoiceMessageCount(in countWaiting : int) : void
        mVmCount = countWaiting;
        int subId = getSubId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {

            Rlog.d(LOG_TAG, "setVoiceMessageCount: Storing Voice Mail Count = " + countWaiting +
                    " for mVmCountKey = " + VM_COUNT + subId + " in preferences.");

            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            SharedPreferences.Editor editor = sp.edit();
            editor.putInt(VM_COUNT + subId, countWaiting);
            editor.apply();
        } else {
            Rlog.e(LOG_TAG, "setVoiceMessageCount in sharedPreference: invalid subId " + subId);
        }
        // notify listeners of voice mail
        notifyMessageWaitingIndicator();
!!!183140.java!!!	getStoredVoiceMessageCount() : int
        int countVoiceMessages = 0;
        int subId = getSubId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            int invalidCount = -2;  //-1 is not really invalid. It is used for unknown number of vm
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int countFromSP = sp.getInt(VM_COUNT + subId, invalidCount);
            if (countFromSP != invalidCount) {
                countVoiceMessages = countFromSP;
                Rlog.d(LOG_TAG, "getStoredVoiceMessageCount: from preference for subId " + subId +
                        "= " + countVoiceMessages);
            } else {
                // Check for old preference if count not found for current subId. This part of the
                // code is needed only when upgrading from M to N.
                String subscriberId = sp.getString(VM_ID, null);
                if (subscriberId != null) {
                    String currentSubscriberId = getSubscriberId();

                    if (currentSubscriberId != null && currentSubscriberId.equals(subscriberId)) {
                        // get voice mail count from preferences
                        countVoiceMessages = sp.getInt(VM_COUNT, 0);
                        setVoiceMessageCount(countVoiceMessages);
                        Rlog.d(LOG_TAG, "getStoredVoiceMessageCount: from preference = " +
                                countVoiceMessages);
                    } else {
                        Rlog.d(LOG_TAG, "getStoredVoiceMessageCount: returning 0 as count for " +
                                "matching subscriberId not found");

                    }
                    // get rid of old preferences.
                    SharedPreferences.Editor editor = sp.edit();
                    editor.remove(VM_ID);
                    editor.remove(VM_COUNT);
                    editor.apply();
                }
            }
        } else {
            Rlog.e(LOG_TAG, "getStoredVoiceMessageCount: invalid subId " + subId);
        }
        return countVoiceMessages;
!!!183268.java!!!	getCdmaEriIconIndex() : int
        return -1;
!!!183396.java!!!	getCdmaEriIconMode() : int
        return -1;
!!!183524.java!!!	getCdmaEriText() : String
        return "GSM nw, no ERI";
!!!183652.java!!!	getCdmaMin() : String
        return null;
!!!183780.java!!!	isMinInfoReady() : boolean
        return false;
!!!183908.java!!!	getCdmaPrlVersion() : String
        return null;
!!!184164.java!!!	setOnPostDialCharacter(inout h : Handler, in what : int, inout obj : Object) : void
        mPostDialHandler = new Registrant(h, what, obj);
!!!184292.java!!!	getPostDialHandler() : Registrant
        return mPostDialHandler;
!!!185060.java!!!	needsOtaServiceProvisioning() : boolean
        return false;
!!!185188.java!!!	isOtaSpNumber(in dialStr : String) : boolean
        return false;
!!!185828.java!!!	registerForSignalInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForSignalInfo(h, what, obj);
!!!185956.java!!!	unregisterForSignalInfo(inout h : Handler) : void
        mCi.unregisterForSignalInfo(h);
!!!186084.java!!!	registerForDisplayInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForDisplayInfo(h, what, obj);
!!!186212.java!!!	unregisterForDisplayInfo(inout h : Handler) : void
         mCi.unregisterForDisplayInfo(h);
!!!186340.java!!!	registerForNumberInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForNumberInfo(h, what, obj);
!!!186468.java!!!	unregisterForNumberInfo(inout h : Handler) : void
        mCi.unregisterForNumberInfo(h);
!!!186596.java!!!	registerForRedirectedNumberInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForRedirectedNumberInfo(h, what, obj);
!!!186724.java!!!	unregisterForRedirectedNumberInfo(inout h : Handler) : void
        mCi.unregisterForRedirectedNumberInfo(h);
!!!186852.java!!!	registerForLineControlInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForLineControlInfo(h, what, obj);
!!!186980.java!!!	unregisterForLineControlInfo(inout h : Handler) : void
        mCi.unregisterForLineControlInfo(h);
!!!187108.java!!!	registerFoT53ClirlInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerFoT53ClirlInfo(h, what, obj);
!!!187236.java!!!	unregisterForT53ClirInfo(inout h : Handler) : void
        mCi.unregisterForT53ClirInfo(h);
!!!187364.java!!!	registerForT53AudioControlInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForT53AudioControlInfo(h, what, obj);
!!!187492.java!!!	unregisterForT53AudioControlInfo(inout h : Handler) : void
        mCi.unregisterForT53AudioControlInfo(h);
!!!187876.java!!!	registerForRadioOffOrNotAvailable(inout h : Handler, in what : int, inout obj : Object) : void
        mRadioOffOrNotAvailableRegistrants.addUnique(h, what, obj);
!!!188004.java!!!	unregisterForRadioOffOrNotAvailable(inout h : Handler) : void
        mRadioOffOrNotAvailableRegistrants.remove(h);
!!!188132.java!!!	getActiveApnTypes() : String
        if (mDcTracker == null) {
            return null;
        }

        return mDcTracker.getActiveApnTypes();
!!!188260.java!!!	hasMatchedTetherApnSetting() : boolean
        return mDcTracker.hasMatchedTetherApnSetting();
!!!188388.java!!!	getActiveApnHost(in apnType : String) : String
        return mDcTracker.getActiveApnString(apnType);
!!!188516.java!!!	getLinkProperties(in apnType : String) : LinkProperties
        return mDcTracker.getLinkProperties(apnType);
!!!188644.java!!!	getNetworkCapabilities(in apnType : String) : NetworkCapabilities
        return mDcTracker.getNetworkCapabilities(apnType);
!!!188772.java!!!	isDataConnectivityPossible() : boolean
        return isDataConnectivityPossible(PhoneConstants.APN_TYPE_DEFAULT);
!!!188900.java!!!	isDataConnectivityPossible(in apnType : String) : boolean
        return ((mDcTracker != null) &&
                (mDcTracker.isDataPossible(apnType)));
!!!189028.java!!!	carrierActionSetMeteredApnsEnabled(inout enabled : boolean) : void
        if(mDcTracker != null) {
            mDcTracker.setApnsEnabledByCarrier(enabled);
        }
!!!189156.java!!!	carrierActionSetRadioEnabled(inout enabled : boolean) : void
        if(mDcTracker != null) {
            mDcTracker.carrierActionSetRadioEnabled(enabled);
        }
!!!189284.java!!!	notifyNewRingingConnectionP(inout cn : Connection) : void
        if (!mIsVoiceCapable)
            return;
        AsyncResult ar = new AsyncResult(null, cn, null);
        mNewRingingConnectionRegistrants.notifyRegistrants(ar);
!!!189412.java!!!	notifyUnknownConnectionP(inout cn : Connection) : void
        mUnknownConnectionRegistrants.notifyResult(cn);
!!!189540.java!!!	notifyForVideoCapabilityChanged(inout isVideoCallCapable : boolean) : void
        // Cache the current video capability so that we don't lose the information.
        mIsVideoCapable = isVideoCallCapable;

        AsyncResult ar = new AsyncResult(null, isVideoCallCapable, null);
        mVideoCapabilityChangedRegistrants.notifyRegistrants(ar);
!!!189668.java!!!	notifyIncomingRing() : void
        if (!mIsVoiceCapable)
            return;
        AsyncResult ar = new AsyncResult(null, this, null);
        mIncomingRingRegistrants.notifyRegistrants(ar);
!!!189796.java!!!	sendIncomingCallRingNotification(in token : int) : void
        if (mIsVoiceCapable && !mDoesRilSendMultipleCallRing &&
                (token == mCallRingContinueToken)) {
            Rlog.d(LOG_TAG, "Sending notifyIncomingRing");
            notifyIncomingRing();
            sendMessageDelayed(
                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
        } else {
            Rlog.d(LOG_TAG, "Ignoring ring notification request,"
                    + " mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing
                    + " token=" + token
                    + " mCallRingContinueToken=" + mCallRingContinueToken
                    + " mIsVoiceCapable=" + mIsVoiceCapable);
        }
!!!189924.java!!!	isCspPlmnEnabled() : boolean
        return false;
!!!190052.java!!!	getIsimRecords() : IsimRecords
        Rlog.e(LOG_TAG, "getIsimRecords() is only supported on LTE devices");
        return null;
!!!190180.java!!!	getMsisdn() : String
        return null;
!!!190308.java!!!	getDataConnectionState() : PhoneConstants.DataState
        return getDataConnectionState(PhoneConstants.APN_TYPE_DEFAULT);
!!!190564.java!!!	notifyDataConnectionFailed(in reason : String, in apnType : String) : void
        mNotifier.notifyDataConnectionFailed(this, reason, apnType);
!!!190692.java!!!	notifyPreciseDataConnectionFailed(in reason : String, in apnType : String, in apn : String, in failCause : String) : void
        mNotifier.notifyPreciseDataConnectionFailed(this, reason, apnType, apn, failCause);
!!!190820.java!!!	getLteOnCdmaMode() : int
        return mCi.getLteOnCdmaMode();
!!!190948.java!!!	setVoiceMessageWaiting(in line : int, in countWaiting : int) : void
        // This function should be overridden by class GsmCdmaPhone.
        Rlog.e(LOG_TAG, "Error! This function should never be executed, inactive Phone.");
!!!191076.java!!!	getUsimServiceTable() : UsimServiceTable
        IccRecords r = mIccRecords.get();
        return (r != null) ? r.getUsimServiceTable() : null;
!!!191204.java!!!	getUiccCard() : UiccCard
        return mUiccController.getUiccCard(mPhoneId);
!!!191332.java!!!	getPcscfAddress(in apnType : String) : String
        return mDcTracker.getPcscfAddress(apnType);
!!!191588.java!!!	getImsPhone() : Phone
        return mImsPhone;
!!!191716.java!!!	isUtEnabled() : boolean
        if (mImsPhone != null) {
            return mImsPhone.isUtEnabled();
        }
        return false;
!!!191972.java!!!	updateImsPhone() : void
        Rlog.d(LOG_TAG, "updateImsPhone"
                + " mImsServiceReady=" + mImsServiceReady);

        if (mImsServiceReady && (mImsPhone == null)) {
            mImsPhone = PhoneFactory.makeImsPhone(mNotifier, this);
            CallManager.getInstance().registerPhone(mImsPhone);
            mImsPhone.registerForSilentRedial(
                    this, EVENT_INITIATE_SILENT_REDIAL, null);
        } else if (!mImsServiceReady && (mImsPhone != null)) {
            CallManager.getInstance().unregisterPhone(mImsPhone);
            mImsPhone.unregisterForSilentRedial(this);

            mImsPhone.dispose();
            // Potential GC issue if someone keeps a reference to ImsPhone.
            // However: this change will make sure that such a reference does
            // not access functions through NULL pointer.
            //mImsPhone.removeReferences();
            mImsPhone = null;
        }
!!!192100.java!!!	dialInternal(in dialString : String, inout uusInfo : UUSInfo, in videoState : int, inout intentExtras : Bundle) : Connection
        // dialInternal shall be overriden by GsmCdmaPhone
        return null;
!!!192228.java!!!	getSubId() : int
        return SubscriptionController.getInstance().getSubIdUsingPhoneId(mPhoneId);
!!!192356.java!!!	getPhoneId() : int
        return mPhoneId;
!!!192484.java!!!	getVoicePhoneServiceState() : int
        Phone imsPhone = mImsPhone;
        if (imsPhone != null
                && imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) {
            return ServiceState.STATE_IN_SERVICE;
        }
        return getServiceState().getState();
!!!192612.java!!!	setOperatorBrandOverride(in brand : String) : boolean
        return false;
!!!192740.java!!!	setRoamingOverride(inout gsmRoamingList : List<String>, inout gsmNonRoamingList : List<String>, inout cdmaRoamingList : List<String>, inout cdmaNonRoamingList : List<String>) : boolean
        String iccId = getIccSerialNumber();
        if (TextUtils.isEmpty(iccId)) {
            return false;
        }

        setRoamingOverrideHelper(gsmRoamingList, GSM_ROAMING_LIST_OVERRIDE_PREFIX, iccId);
        setRoamingOverrideHelper(gsmNonRoamingList, GSM_NON_ROAMING_LIST_OVERRIDE_PREFIX, iccId);
        setRoamingOverrideHelper(cdmaRoamingList, CDMA_ROAMING_LIST_OVERRIDE_PREFIX, iccId);
        setRoamingOverrideHelper(cdmaNonRoamingList, CDMA_NON_ROAMING_LIST_OVERRIDE_PREFIX, iccId);

        // Refresh.
        ServiceStateTracker tracker = getServiceStateTracker();
        if (tracker != null) {
            tracker.pollState();
        }
        return true;
!!!192868.java!!!	setRoamingOverrideHelper(inout list : List<String>, in prefix : String, in iccId : String) : void
        SharedPreferences.Editor spEditor =
                PreferenceManager.getDefaultSharedPreferences(mContext).edit();
        String key = prefix + iccId;
        if (list == null || list.isEmpty()) {
            spEditor.remove(key).commit();
        } else {
            spEditor.putStringSet(key, new HashSet<String>(list)).commit();
        }
!!!192996.java!!!	isMccMncMarkedAsRoaming(in mccMnc : String) : boolean
        return getRoamingOverrideHelper(GSM_ROAMING_LIST_OVERRIDE_PREFIX, mccMnc);
!!!193124.java!!!	isMccMncMarkedAsNonRoaming(in mccMnc : String) : boolean
        return getRoamingOverrideHelper(GSM_NON_ROAMING_LIST_OVERRIDE_PREFIX, mccMnc);
!!!193252.java!!!	isSidMarkedAsRoaming(in SID : int) : boolean
        return getRoamingOverrideHelper(CDMA_ROAMING_LIST_OVERRIDE_PREFIX,
                Integer.toString(SID));
!!!193380.java!!!	isSidMarkedAsNonRoaming(in SID : int) : boolean
        return getRoamingOverrideHelper(CDMA_NON_ROAMING_LIST_OVERRIDE_PREFIX,
                Integer.toString(SID));
!!!193508.java!!!	isImsRegistered() : boolean
        Phone imsPhone = mImsPhone;
        boolean isImsRegistered = false;
        if (imsPhone != null) {
            isImsRegistered = imsPhone.isImsRegistered();
        } else {
            ServiceStateTracker sst = getServiceStateTracker();
            if (sst != null) {
                isImsRegistered = sst.isImsRegistered();
            }
        }
        Rlog.d(LOG_TAG, "isImsRegistered =" + isImsRegistered);
        return isImsRegistered;
!!!193636.java!!!	isWifiCallingEnabled() : boolean
        Phone imsPhone = mImsPhone;
        boolean isWifiCallingEnabled = false;
        if (imsPhone != null) {
            isWifiCallingEnabled = imsPhone.isWifiCallingEnabled();
        }
        Rlog.d(LOG_TAG, "isWifiCallingEnabled =" + isWifiCallingEnabled);
        return isWifiCallingEnabled;
!!!193764.java!!!	isVolteEnabled() : boolean
        Phone imsPhone = mImsPhone;
        boolean isVolteEnabled = false;
        if (imsPhone != null) {
            isVolteEnabled = imsPhone.isVolteEnabled();
        }
        Rlog.d(LOG_TAG, "isImsRegistered =" + isVolteEnabled);
        return isVolteEnabled;
!!!193892.java!!!	getRoamingOverrideHelper(in prefix : String, in key : String) : boolean
        String iccId = getIccSerialNumber();
        if (TextUtils.isEmpty(iccId) || TextUtils.isEmpty(key)) {
            return false;
        }

        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
        Set<String> value = sp.getStringSet(prefix + iccId, null);
        if (value == null) {
            return false;
        }
        return value.contains(key);
!!!194020.java!!!	isRadioAvailable() : boolean
        return mCi.getRadioState().isAvailable();
!!!194148.java!!!	isRadioOn() : boolean
        return mCi.getRadioState().isOn();
!!!194276.java!!!	shutdownRadio() : void
        getServiceStateTracker().requestShutdown();
!!!194404.java!!!	isShuttingDown() : boolean
        return getServiceStateTracker().isDeviceShuttingDown();
!!!194532.java!!!	setRadioCapability(inout rc : RadioCapability, inout response : Message) : void
        mCi.setRadioCapability(rc, response);
!!!194660.java!!!	getRadioAccessFamily() : int
        final RadioCapability rc = getRadioCapability();
        return (rc == null ? RadioAccessFamily.RAF_UNKNOWN : rc.getRadioAccessFamily());
!!!194788.java!!!	getModemUuId() : String
        final RadioCapability rc = getRadioCapability();
        return (rc == null ? "" : rc.getLogicalModemUuid());
!!!194916.java!!!	getRadioCapability() : RadioCapability
        return mRadioCapability.get();
!!!195044.java!!!	radioCapabilityUpdated(inout rc : RadioCapability) : void
        // Called when radios first become available or after a capability switch
        // Update the cached value
        mRadioCapability.set(rc);

        if (SubscriptionManager.isValidSubscriptionId(getSubId())) {
            sendSubscriptionSettings(true);
        }
!!!195172.java!!!	sendSubscriptionSettings(inout restoreNetworkSelection : boolean) : void
        // Send settings down
        int type = PhoneFactory.calculatePreferredNetworkType(mContext, getSubId());
        setPreferredNetworkType(type, null);

        if (restoreNetworkSelection) {
            restoreSavedNetworkSelection(null);
        }
!!!195300.java!!!	setPreferredNetworkTypeIfSimLoaded() : void
        int subId = getSubId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            int type = PhoneFactory.calculatePreferredNetworkType(mContext, getSubId());
            setPreferredNetworkType(type, null);
        }
!!!195428.java!!!	registerForRadioCapabilityChanged(inout h : Handler, in what : int, inout obj : Object) : void
        mCi.registerForRadioCapabilityChanged(h, what, obj);
!!!195556.java!!!	unregisterForRadioCapabilityChanged(inout h : Handler) : void
        mCi.unregisterForRadioCapabilityChanged(this);
!!!195684.java!!!	isImsUseEnabled() : boolean
        boolean imsUseEnabled =
                ((ImsManager.isVolteEnabledByPlatform(mContext) &&
                ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext)) ||
                (ImsManager.isWfcEnabledByPlatform(mContext) &&
                ImsManager.isWfcEnabledByUser(mContext)) &&
                ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext));
        return imsUseEnabled;
!!!195812.java!!!	isVideoEnabled() : boolean
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null)
                && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            return imsPhone.isVideoEnabled();
        }
        return false;
!!!195940.java!!!	getLceStatus() : int
        return mLceStatus;
!!!196068.java!!!	getModemActivityInfo(inout response : Message) : void
        mCi.getModemActivityInfo(response);
!!!196196.java!!!	startLceAfterRadioIsAvailable() : void
        mCi.startLceService(DEFAULT_REPORT_INTERVAL_MS, LCE_PULL_MODE,
                obtainMessage(EVENT_CONFIG_LCE));
!!!196324.java!!!	setAllowedCarriers(inout carriers : List<CarrierIdentifier>, inout response : Message) : void
        mCi.setAllowedCarriers(carriers, response);
!!!196452.java!!!	getAllowedCarriers(inout response : Message) : void
        mCi.getAllowedCarriers(response);
!!!196580.java!!!	getLocaleFromSimAndCarrierPrefs() : Locale
        final IccRecords records = mIccRecords.get();
        if (records != null && records.getSimLanguage() != null) {
            return new Locale(records.getSimLanguage());
        }

        return getLocaleFromCarrierProperties(mContext);
!!!196708.java!!!	updateDataConnectionTracker() : void
        mDcTracker.update();
!!!196836.java!!!	setInternalDataEnabled(inout enable : boolean, inout onCompleteMsg : Message) : void
        mDcTracker.setInternalDataEnabled(enable, onCompleteMsg);
!!!196964.java!!!	updateCurrentCarrierInProvider() : boolean
        return false;
!!!197092.java!!!	registerForAllDataDisconnected(inout h : Handler, in what : int, inout obj : Object) : void
        mDcTracker.registerForAllDataDisconnected(h, what, obj);
!!!197220.java!!!	unregisterForAllDataDisconnected(inout h : Handler) : void
        mDcTracker.unregisterForAllDataDisconnected(h);
!!!197348.java!!!	registerForDataEnabledChanged(inout h : Handler, in what : int, inout obj : Object) : void
        mDcTracker.registerForDataEnabledChanged(h, what, obj);
!!!197476.java!!!	unregisterForDataEnabledChanged(inout h : Handler) : void
        mDcTracker.unregisterForDataEnabledChanged(h);
!!!197604.java!!!	getIccSmsInterfaceManager() : IccSmsInterfaceManager
        return null;
!!!197732.java!!!	isMatchGid(in gid : String) : boolean
        String gid1 = getGroupIdLevel1();
        int gidLength = gid.length();
        if (!TextUtils.isEmpty(gid1) && (gid1.length() >= gidLength)
                && gid1.substring(0, gidLength).equalsIgnoreCase(gid)) {
            return true;
        }
        return false;
!!!197860.java!!!	checkWfcWifiOnlyModeBeforeDial(inout imsPhone : Phone, inout context : Context) : void
        if (imsPhone == null || !imsPhone.isWifiCallingEnabled()) {
            boolean wfcWiFiOnly = (ImsManager.isWfcEnabledByPlatform(context) &&
                    ImsManager.isWfcEnabledByUser(context) &&
                    (ImsManager.getWfcMode(context) ==
                            ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY));
            if (wfcWiFiOnly) {
                throw new CallStateException(
                        CallStateException.ERROR_DISCONNECTED,
                        "WFC Wi-Fi Only Mode: IMS not registered");
            }
        }
!!!198756.java!!!	getDefaultPhone() : Phone
        return this;
!!!198884.java!!!	getVtDataUsage() : long
        if (mImsPhone == null) return 0;
        return mImsPhone.getVtDataUsage();
!!!199012.java!!!	setPolicyDataEnabled(inout enabled : boolean) : void
        mDcTracker.setPolicyDataEnabled(enabled);
!!!199140.java!!!	getCurrentSubscriberUris() : Uri
        return null;
!!!199268.java!!!	dump(inout fd : FileDescriptor, inout pw : PrintWriter, inout args : String [[]]) : void
        pw.println("Phone: subId=" + getSubId());
        pw.println(" mPhoneId=" + mPhoneId);
        pw.println(" mCi=" + mCi);
        pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
        pw.println(" mDcTracker=" + mDcTracker);
        pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
        pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
        pw.println(" mCallRingDelay=" + mCallRingDelay);
        pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
        pw.println(" mIccRecords=" + mIccRecords.get());
        pw.println(" mUiccApplication=" + mUiccApplication.get());
        pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
        pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
        pw.flush();
        pw.println(" mLooper=" + mLooper);
        pw.println(" mContext=" + mContext);
        pw.println(" mNotifier=" + mNotifier);
        pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
        pw.println(" mUnitTestMode=" + mUnitTestMode);
        pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
        pw.println(" getUnitTestMode()=" + getUnitTestMode());
        pw.println(" getState()=" + getState());
        pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
        pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
        pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
        pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
        pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
        pw.flush();
        pw.println(" isInEcm()=" + isInEcm());
        pw.println(" getPhoneName()=" + getPhoneName());
        pw.println(" getPhoneType()=" + getPhoneType());
        pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
        pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
        pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
        pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");

        if (mImsPhone != null) {
            try {
                mImsPhone.dump(fd, pw, args);
            } catch (Exception e) {
                e.printStackTrace();
            }

            pw.flush();
            pw.println("++++++++++++++++++++++++++++++++");
        }

        if (mDcTracker != null) {
            try {
                mDcTracker.dump(fd, pw, args);
            } catch (Exception e) {
                e.printStackTrace();
            }

            pw.flush();
            pw.println("++++++++++++++++++++++++++++++++");
        }

        if (getServiceStateTracker() != null) {
            try {
                getServiceStateTracker().dump(fd, pw, args);
            } catch (Exception e) {
                e.printStackTrace();
            }

            pw.flush();
            pw.println("++++++++++++++++++++++++++++++++");
        }

        if (getCallTracker() != null) {
            try {
                getCallTracker().dump(fd, pw, args);
            } catch (Exception e) {
                e.printStackTrace();
            }

            pw.flush();
            pw.println("++++++++++++++++++++++++++++++++");
        }

        if (mCi != null && mCi instanceof RIL) {
            try {
                ((RIL)mCi).dump(fd, pw, args);
            } catch (Exception e) {
                e.printStackTrace();
            }

            pw.flush();
            pw.println("++++++++++++++++++++++++++++++++");
        }
